/**
 * middleware/webhookSignatureMiddleware.js
 * -----------------------------------------
 * Verifies webhook signatures from Sendbird and Stripe.
 *
 * WHY SIGNATURE VERIFICATION MATTERS:
 *   Without signature verification, anyone who knows your webhook URL can
 *   send crafted payloads to your server:
 *
 *   - Fake Stripe event saying "payment succeeded" → transaction marked as success
 *     without any real money being transferred. User gets service for free.
 *
 *   - Fake Sendbird event saying a user sent "REFUND TXN1001" → bot issues
 *     a refund that the real user never requested.
 *
 *   Signatures prove the webhook payload was generated by the real vendor
 *   using a shared secret that only they and we know.
 *
 * SENDBIRD SIGNATURE:
 *   Sendbird computes HMAC-SHA256(API_TOKEN, raw_body) and puts it in
 *   x-sendbird-signature header. We verify by computing the same HMAC.
 *
 * STRIPE SIGNATURE:
 *   Stripe uses stripe.webhooks.constructEvent() which verifies the
 *   Stripe-Signature header against the STRIPE_WEBHOOK_SECRET.
 *   Already handled in the payment webhook handler — this file adds
 *   Sendbird verification.
 */

const crypto = require("crypto");

/**
 * Verify Sendbird webhook signature.
 * Sendbird signs: HMAC-SHA256(SENDBIRD_API_TOKEN, rawBody)
 * and puts result in x-sendbird-signature header (hex string).
 *
 * NOTE: req.rawBody must be populated by express.json verify callback.
 *       If SENDBIRD_API_TOKEN is not set, verification is skipped (dev mode).
 *
 * @param {object} req - Express request
 * @param {object} res - Express response
 * @param {function} next - next middleware
 */
function verifySendbirdSignature(req, res, next) {
  const apiToken = process.env.SENDBIRD_API_TOKEN;

  // Skip verification in dev if no token set (unlikely in production)
  if (!apiToken) {
    return next();
  }

  const signature = req.headers["x-sendbird-signature"];

  // If Sendbird didn't send a signature header, reject the request
  // UNLESS we're in development mode (allows testing with tools like curl/Postman)
  if (!signature) {
    if (process.env.NODE_ENV === "production") {
      console.warn("⚠️  Sendbird webhook missing x-sendbird-signature header — rejecting");
      return res.status(401).json({ error: "Missing webhook signature" });
    }
    // Dev mode: warn but allow through
    console.warn("⚠️  [DEV] Missing x-sendbird-signature — skipping verification");
    return next();
  }

  const rawBody = req.rawBody;
  if (!rawBody) {
    // rawBody is populated by the express.json verify callback for this route
    console.warn("⚠️  rawBody not available for signature verification");
    return next(); // fail open — rawBody setup issue, not a security attack
  }

  try {
    const expectedSignature = crypto
      .createHmac("sha256", apiToken)
      .update(rawBody)
      .digest("hex");

    // Constant-time comparison to prevent timing attacks
    const sigBuffer      = Buffer.from(signature, "hex");
    const expectedBuffer = Buffer.from(expectedSignature, "hex");

    if (sigBuffer.length !== expectedBuffer.length ||
        !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
      console.warn("⚠️  Sendbird webhook signature mismatch — rejecting request");
      if (process.env.NODE_ENV === "production") {
        return res.status(401).json({ error: "Invalid webhook signature" });
      }
      // Dev mode: warn but allow through so local testing works without
      // matching the exact SENDBIRD_API_TOKEN that Sendbird signs with.
      console.warn("⚠️  [DEV] Signature mismatch — allowing through (non-production mode)");
      return next();
    }

    next();
  } catch (err) {
    console.warn("⚠️  Sendbird signature verification error:", err.message);
    // On verification error in dev, allow through; in prod, reject
    if (process.env.NODE_ENV === "production") {
      return res.status(401).json({ error: "Signature verification failed" });
    }
    next();
  }
}

module.exports = { verifySendbirdSignature };
